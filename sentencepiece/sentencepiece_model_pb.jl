# Autogenerated using ProtoBuf.jl v1.0.11 on 2023-08-01T22:43:08.780
# original file: /Users/eph/LanguageModels.jl/sentencepiece_model.proto (proto2 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export NormalizerSpec, var"ModelProto.SentencePiece.Type", var"SelfTestData.Sample"
export var"TrainerSpec.ModelType", var"ModelProto.SentencePiece", SelfTestData, TrainerSpec
export ModelProto

struct NormalizerSpec
    name::String
    precompiled_charsmap::Vector{UInt8}
    add_dummy_prefix::Bool
    remove_extra_whitespaces::Bool
    escape_whitespaces::Bool
    normalization_rule_tsv::String
end
PB.extendable_field_numbers(::Type{NormalizerSpec}) = Union{Int,UnitRange{Int}}[200:536870911]
PB.default_values(::Type{NormalizerSpec}) = (;name = "", precompiled_charsmap = UInt8[], add_dummy_prefix = true, remove_extra_whitespaces = true, escape_whitespaces = true, normalization_rule_tsv = "")
PB.field_numbers(::Type{NormalizerSpec}) = (;name = 1, precompiled_charsmap = 2, add_dummy_prefix = 3, remove_extra_whitespaces = 4, escape_whitespaces = 5, normalization_rule_tsv = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:NormalizerSpec})
    name = ""
    precompiled_charsmap = UInt8[]
    add_dummy_prefix = true
    remove_extra_whitespaces = true
    escape_whitespaces = true
    normalization_rule_tsv = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            precompiled_charsmap = PB.decode(d, Vector{UInt8})
        elseif field_number == 3
            add_dummy_prefix = PB.decode(d, Bool)
        elseif field_number == 4
            remove_extra_whitespaces = PB.decode(d, Bool)
        elseif field_number == 5
            escape_whitespaces = PB.decode(d, Bool)
        elseif field_number == 6
            normalization_rule_tsv = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return NormalizerSpec(name, precompiled_charsmap, add_dummy_prefix, remove_extra_whitespaces, escape_whitespaces, normalization_rule_tsv)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::NormalizerSpec)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.precompiled_charsmap) && PB.encode(e, 2, x.precompiled_charsmap)
    x.add_dummy_prefix != true && PB.encode(e, 3, x.add_dummy_prefix)
    x.remove_extra_whitespaces != true && PB.encode(e, 4, x.remove_extra_whitespaces)
    x.escape_whitespaces != true && PB.encode(e, 5, x.escape_whitespaces)
    !isempty(x.normalization_rule_tsv) && PB.encode(e, 6, x.normalization_rule_tsv)
    return position(e.io) - initpos
end
function PB._encoded_size(x::NormalizerSpec)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.precompiled_charsmap) && (encoded_size += PB._encoded_size(x.precompiled_charsmap, 2))
    x.add_dummy_prefix != true && (encoded_size += PB._encoded_size(x.add_dummy_prefix, 3))
    x.remove_extra_whitespaces != true && (encoded_size += PB._encoded_size(x.remove_extra_whitespaces, 4))
    x.escape_whitespaces != true && (encoded_size += PB._encoded_size(x.escape_whitespaces, 5))
    !isempty(x.normalization_rule_tsv) && (encoded_size += PB._encoded_size(x.normalization_rule_tsv, 6))
    return encoded_size
end

@enumx var"ModelProto.SentencePiece.Type" NORMAL=1 UNKNOWN=2 CONTROL=3 USER_DEFINED=4 BYTE=6 UNUSED=5

struct var"SelfTestData.Sample"
    input::String
    expected::String
end
PB.default_values(::Type{var"SelfTestData.Sample"}) = (;input = "", expected = "")
PB.field_numbers(::Type{var"SelfTestData.Sample"}) = (;input = 1, expected = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"SelfTestData.Sample"})
    input = ""
    expected = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            input = PB.decode(d, String)
        elseif field_number == 2
            expected = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"SelfTestData.Sample"(input, expected)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"SelfTestData.Sample")
    initpos = position(e.io)
    !isempty(x.input) && PB.encode(e, 1, x.input)
    !isempty(x.expected) && PB.encode(e, 2, x.expected)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"SelfTestData.Sample")
    encoded_size = 0
    !isempty(x.input) && (encoded_size += PB._encoded_size(x.input, 1))
    !isempty(x.expected) && (encoded_size += PB._encoded_size(x.expected, 2))
    return encoded_size
end

@enumx var"TrainerSpec.ModelType" UNIGRAM=1 BPE=2 WORD=3 CHAR=4

struct var"ModelProto.SentencePiece"
    piece::String
    score::Float32
    var"#type"::var"ModelProto.SentencePiece.Type".T
end
PB.extendable_field_numbers(::Type{var"ModelProto.SentencePiece"}) = Union{Int,UnitRange{Int}}[200:536870911]
PB.default_values(::Type{var"ModelProto.SentencePiece"}) = (;piece = "", score = zero(Float32), var"#type" = var"ModelProto.SentencePiece.Type".NORMAL)
PB.field_numbers(::Type{var"ModelProto.SentencePiece"}) = (;piece = 1, score = 2, var"#type" = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"ModelProto.SentencePiece"})
    piece = ""
    score = zero(Float32)
    var"#type" = var"ModelProto.SentencePiece.Type".NORMAL
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            piece = PB.decode(d, String)
        elseif field_number == 2
            score = PB.decode(d, Float32)
        elseif field_number == 3
            var"#type" = PB.decode(d, var"ModelProto.SentencePiece.Type".T)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"ModelProto.SentencePiece"(piece, score, var"#type")
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"ModelProto.SentencePiece")
    initpos = position(e.io)
    !isempty(x.piece) && PB.encode(e, 1, x.piece)
    x.score != zero(Float32) && PB.encode(e, 2, x.score)
    x.var"#type" != var"ModelProto.SentencePiece.Type".NORMAL && PB.encode(e, 3, x.var"#type")
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"ModelProto.SentencePiece")
    encoded_size = 0
    !isempty(x.piece) && (encoded_size += PB._encoded_size(x.piece, 1))
    x.score != zero(Float32) && (encoded_size += PB._encoded_size(x.score, 2))
    x.var"#type" != var"ModelProto.SentencePiece.Type".NORMAL && (encoded_size += PB._encoded_size(x.var"#type", 3))
    return encoded_size
end

struct SelfTestData
    samples::Vector{var"SelfTestData.Sample"}
end
PB.extendable_field_numbers(::Type{SelfTestData}) = Union{Int,UnitRange{Int}}[200:536870911]
PB.default_values(::Type{SelfTestData}) = (;samples = Vector{var"SelfTestData.Sample"}())
PB.field_numbers(::Type{SelfTestData}) = (;samples = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SelfTestData})
    samples = PB.BufferedVector{var"SelfTestData.Sample"}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, samples)
        else
            PB.skip(d, wire_type)
        end
    end
    return SelfTestData(samples[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SelfTestData)
    initpos = position(e.io)
    !isempty(x.samples) && PB.encode(e, 1, x.samples)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SelfTestData)
    encoded_size = 0
    !isempty(x.samples) && (encoded_size += PB._encoded_size(x.samples, 1))
    return encoded_size
end

struct TrainerSpec
    input::Vector{String}
    input_format::String
    model_prefix::String
    model_type::var"TrainerSpec.ModelType".T
    vocab_size::Int32
    accept_language::Vector{String}
    self_test_sample_size::Int32
    enable_differential_privacy::Bool
    differential_privacy_noise_level::Float32
    differential_privacy_clipping_threshold::UInt64
    character_coverage::Float32
    input_sentence_size::UInt64
    shuffle_input_sentence::Bool
    mining_sentence_size::Int32
    training_sentence_size::Int32
    seed_sentencepiece_size::Int32
    shrinking_factor::Float32
    max_sentence_length::Int32
    num_threads::Int32
    num_sub_iterations::Int32
    max_sentencepiece_length::Int32
    split_by_unicode_script::Bool
    split_by_number::Bool
    split_by_whitespace::Bool
    treat_whitespace_as_suffix::Bool
    allow_whitespace_only_pieces::Bool
    split_digits::Bool
    pretokenization_delimiter::String
    control_symbols::Vector{String}
    user_defined_symbols::Vector{String}
    required_chars::String
    byte_fallback::Bool
    vocabulary_output_piece_score::Bool
    hard_vocab_limit::Bool
    use_all_vocab::Bool
    unk_id::Int32
    bos_id::Int32
    eos_id::Int32
    pad_id::Int32
    unk_piece::String
    bos_piece::String
    eos_piece::String
    pad_piece::String
    unk_surface::String
    train_extremely_large_corpus::Bool
end
PB.extendable_field_numbers(::Type{TrainerSpec}) = Union{Int,UnitRange{Int}}[200:536870911]
PB.default_values(::Type{TrainerSpec}) = (;input = Vector{String}(), input_format = "", model_prefix = "", model_type = var"TrainerSpec.ModelType".UNIGRAM, vocab_size = Int32(8000), accept_language = Vector{String}(), self_test_sample_size = Int32(0), enable_differential_privacy = false, differential_privacy_noise_level = Float32(0.0), differential_privacy_clipping_threshold = UInt64(0x0000000000000000), character_coverage = Float32(0.9995), input_sentence_size = UInt64(0x0000000000000000), shuffle_input_sentence = true, mining_sentence_size = zero(Int32), training_sentence_size = zero(Int32), seed_sentencepiece_size = Int32(1000000), shrinking_factor = Float32(0.75), max_sentence_length = Int32(4192), num_threads = Int32(16), num_sub_iterations = Int32(2), max_sentencepiece_length = Int32(16), split_by_unicode_script = true, split_by_number = true, split_by_whitespace = true, treat_whitespace_as_suffix = false, allow_whitespace_only_pieces = false, split_digits = false, pretokenization_delimiter = "", control_symbols = Vector{String}(), user_defined_symbols = Vector{String}(), required_chars = "", byte_fallback = false, vocabulary_output_piece_score = true, hard_vocab_limit = true, use_all_vocab = false, unk_id = Int32(0), bos_id = Int32(1), eos_id = Int32(2), pad_id = Int32(-1), unk_piece = "<unk>", bos_piece = "<s>", eos_piece = "</s>", pad_piece = "<pad>", unk_surface = " \xE2\x81\x87 ", train_extremely_large_corpus = false)
PB.field_numbers(::Type{TrainerSpec}) = (;input = 1, input_format = 7, model_prefix = 2, model_type = 3, vocab_size = 4, accept_language = 5, self_test_sample_size = 6, enable_differential_privacy = 50, differential_privacy_noise_level = 51, differential_privacy_clipping_threshold = 52, character_coverage = 10, input_sentence_size = 11, shuffle_input_sentence = 19, mining_sentence_size = 12, training_sentence_size = 13, seed_sentencepiece_size = 14, shrinking_factor = 15, max_sentence_length = 18, num_threads = 16, num_sub_iterations = 17, max_sentencepiece_length = 20, split_by_unicode_script = 21, split_by_number = 23, split_by_whitespace = 22, treat_whitespace_as_suffix = 24, allow_whitespace_only_pieces = 26, split_digits = 25, pretokenization_delimiter = 53, control_symbols = 30, user_defined_symbols = 31, required_chars = 36, byte_fallback = 35, vocabulary_output_piece_score = 32, hard_vocab_limit = 33, use_all_vocab = 34, unk_id = 40, bos_id = 41, eos_id = 42, pad_id = 43, unk_piece = 45, bos_piece = 46, eos_piece = 47, pad_piece = 48, unk_surface = 44, train_extremely_large_corpus = 49)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TrainerSpec})
    input = PB.BufferedVector{String}()
    input_format = ""
    model_prefix = ""
    model_type = var"TrainerSpec.ModelType".UNIGRAM
    vocab_size = Int32(8000)
    accept_language = PB.BufferedVector{String}()
    self_test_sample_size = Int32(0)
    enable_differential_privacy = false
    differential_privacy_noise_level = Float32(0.0)
    differential_privacy_clipping_threshold = UInt64(0x0000000000000000)
    character_coverage = Float32(0.9995)
    input_sentence_size = UInt64(0x0000000000000000)
    shuffle_input_sentence = true
    mining_sentence_size = zero(Int32)
    training_sentence_size = zero(Int32)
    seed_sentencepiece_size = Int32(1000000)
    shrinking_factor = Float32(0.75)
    max_sentence_length = Int32(4192)
    num_threads = Int32(16)
    num_sub_iterations = Int32(2)
    max_sentencepiece_length = Int32(16)
    split_by_unicode_script = true
    split_by_number = true
    split_by_whitespace = true
    treat_whitespace_as_suffix = false
    allow_whitespace_only_pieces = false
    split_digits = false
    pretokenization_delimiter = ""
    control_symbols = PB.BufferedVector{String}()
    user_defined_symbols = PB.BufferedVector{String}()
    required_chars = ""
    byte_fallback = false
    vocabulary_output_piece_score = true
    hard_vocab_limit = true
    use_all_vocab = false
    unk_id = Int32(0)
    bos_id = Int32(1)
    eos_id = Int32(2)
    pad_id = Int32(-1)
    unk_piece = "<unk>"
    bos_piece = "<s>"
    eos_piece = "</s>"
    pad_piece = "<pad>"
    unk_surface = " \xE2\x81\x87 "
    train_extremely_large_corpus = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, input)
        elseif field_number == 7
            input_format = PB.decode(d, String)
        elseif field_number == 2
            model_prefix = PB.decode(d, String)
        elseif field_number == 3
            model_type = PB.decode(d, var"TrainerSpec.ModelType".T)
        elseif field_number == 4
            vocab_size = PB.decode(d, Int32)
        elseif field_number == 5
            PB.decode!(d, accept_language)
        elseif field_number == 6
            self_test_sample_size = PB.decode(d, Int32)
        elseif field_number == 50
            enable_differential_privacy = PB.decode(d, Bool)
        elseif field_number == 51
            differential_privacy_noise_level = PB.decode(d, Float32)
        elseif field_number == 52
            differential_privacy_clipping_threshold = PB.decode(d, UInt64)
        elseif field_number == 10
            character_coverage = PB.decode(d, Float32)
        elseif field_number == 11
            input_sentence_size = PB.decode(d, UInt64)
        elseif field_number == 19
            shuffle_input_sentence = PB.decode(d, Bool)
        elseif field_number == 12
            mining_sentence_size = PB.decode(d, Int32)
        elseif field_number == 13
            training_sentence_size = PB.decode(d, Int32)
        elseif field_number == 14
            seed_sentencepiece_size = PB.decode(d, Int32)
        elseif field_number == 15
            shrinking_factor = PB.decode(d, Float32)
        elseif field_number == 18
            max_sentence_length = PB.decode(d, Int32)
        elseif field_number == 16
            num_threads = PB.decode(d, Int32)
        elseif field_number == 17
            num_sub_iterations = PB.decode(d, Int32)
        elseif field_number == 20
            max_sentencepiece_length = PB.decode(d, Int32)
        elseif field_number == 21
            split_by_unicode_script = PB.decode(d, Bool)
        elseif field_number == 23
            split_by_number = PB.decode(d, Bool)
        elseif field_number == 22
            split_by_whitespace = PB.decode(d, Bool)
        elseif field_number == 24
            treat_whitespace_as_suffix = PB.decode(d, Bool)
        elseif field_number == 26
            allow_whitespace_only_pieces = PB.decode(d, Bool)
        elseif field_number == 25
            split_digits = PB.decode(d, Bool)
        elseif field_number == 53
            pretokenization_delimiter = PB.decode(d, String)
        elseif field_number == 30
            PB.decode!(d, control_symbols)
        elseif field_number == 31
            PB.decode!(d, user_defined_symbols)
        elseif field_number == 36
            required_chars = PB.decode(d, String)
        elseif field_number == 35
            byte_fallback = PB.decode(d, Bool)
        elseif field_number == 32
            vocabulary_output_piece_score = PB.decode(d, Bool)
        elseif field_number == 33
            hard_vocab_limit = PB.decode(d, Bool)
        elseif field_number == 34
            use_all_vocab = PB.decode(d, Bool)
        elseif field_number == 40
            unk_id = PB.decode(d, Int32)
        elseif field_number == 41
            bos_id = PB.decode(d, Int32)
        elseif field_number == 42
            eos_id = PB.decode(d, Int32)
        elseif field_number == 43
            pad_id = PB.decode(d, Int32)
        elseif field_number == 45
            unk_piece = PB.decode(d, String)
        elseif field_number == 46
            bos_piece = PB.decode(d, String)
        elseif field_number == 47
            eos_piece = PB.decode(d, String)
        elseif field_number == 48
            pad_piece = PB.decode(d, String)
        elseif field_number == 44
            unk_surface = PB.decode(d, String)
        elseif field_number == 49
            train_extremely_large_corpus = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return TrainerSpec(input[], input_format, model_prefix, model_type, vocab_size, accept_language[], self_test_sample_size, enable_differential_privacy, differential_privacy_noise_level, differential_privacy_clipping_threshold, character_coverage, input_sentence_size, shuffle_input_sentence, mining_sentence_size, training_sentence_size, seed_sentencepiece_size, shrinking_factor, max_sentence_length, num_threads, num_sub_iterations, max_sentencepiece_length, split_by_unicode_script, split_by_number, split_by_whitespace, treat_whitespace_as_suffix, allow_whitespace_only_pieces, split_digits, pretokenization_delimiter, control_symbols[], user_defined_symbols[], required_chars, byte_fallback, vocabulary_output_piece_score, hard_vocab_limit, use_all_vocab, unk_id, bos_id, eos_id, pad_id, unk_piece, bos_piece, eos_piece, pad_piece, unk_surface, train_extremely_large_corpus)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TrainerSpec)
    initpos = position(e.io)
    !isempty(x.input) && PB.encode(e, 1, x.input)
    !isempty(x.input_format) && PB.encode(e, 7, x.input_format)
    !isempty(x.model_prefix) && PB.encode(e, 2, x.model_prefix)
    x.model_type != var"TrainerSpec.ModelType".UNIGRAM && PB.encode(e, 3, x.model_type)
    x.vocab_size != Int32(8000) && PB.encode(e, 4, x.vocab_size)
    !isempty(x.accept_language) && PB.encode(e, 5, x.accept_language)
    x.self_test_sample_size != Int32(0) && PB.encode(e, 6, x.self_test_sample_size)
    x.enable_differential_privacy != false && PB.encode(e, 50, x.enable_differential_privacy)
    x.differential_privacy_noise_level != Float32(0.0) && PB.encode(e, 51, x.differential_privacy_noise_level)
    x.differential_privacy_clipping_threshold != UInt64(0x0000000000000000) && PB.encode(e, 52, x.differential_privacy_clipping_threshold)
    x.character_coverage != Float32(0.9995) && PB.encode(e, 10, x.character_coverage)
    x.input_sentence_size != UInt64(0x0000000000000000) && PB.encode(e, 11, x.input_sentence_size)
    x.shuffle_input_sentence != true && PB.encode(e, 19, x.shuffle_input_sentence)
    x.mining_sentence_size != zero(Int32) && PB.encode(e, 12, x.mining_sentence_size)
    x.training_sentence_size != zero(Int32) && PB.encode(e, 13, x.training_sentence_size)
    x.seed_sentencepiece_size != Int32(1000000) && PB.encode(e, 14, x.seed_sentencepiece_size)
    x.shrinking_factor != Float32(0.75) && PB.encode(e, 15, x.shrinking_factor)
    x.max_sentence_length != Int32(4192) && PB.encode(e, 18, x.max_sentence_length)
    x.num_threads != Int32(16) && PB.encode(e, 16, x.num_threads)
    x.num_sub_iterations != Int32(2) && PB.encode(e, 17, x.num_sub_iterations)
    x.max_sentencepiece_length != Int32(16) && PB.encode(e, 20, x.max_sentencepiece_length)
    x.split_by_unicode_script != true && PB.encode(e, 21, x.split_by_unicode_script)
    x.split_by_number != true && PB.encode(e, 23, x.split_by_number)
    x.split_by_whitespace != true && PB.encode(e, 22, x.split_by_whitespace)
    x.treat_whitespace_as_suffix != false && PB.encode(e, 24, x.treat_whitespace_as_suffix)
    x.allow_whitespace_only_pieces != false && PB.encode(e, 26, x.allow_whitespace_only_pieces)
    x.split_digits != false && PB.encode(e, 25, x.split_digits)
    x.pretokenization_delimiter != "" && PB.encode(e, 53, x.pretokenization_delimiter)
    !isempty(x.control_symbols) && PB.encode(e, 30, x.control_symbols)
    !isempty(x.user_defined_symbols) && PB.encode(e, 31, x.user_defined_symbols)
    !isempty(x.required_chars) && PB.encode(e, 36, x.required_chars)
    x.byte_fallback != false && PB.encode(e, 35, x.byte_fallback)
    x.vocabulary_output_piece_score != true && PB.encode(e, 32, x.vocabulary_output_piece_score)
    x.hard_vocab_limit != true && PB.encode(e, 33, x.hard_vocab_limit)
    x.use_all_vocab != false && PB.encode(e, 34, x.use_all_vocab)
    x.unk_id != Int32(0) && PB.encode(e, 40, x.unk_id)
    x.bos_id != Int32(1) && PB.encode(e, 41, x.bos_id)
    x.eos_id != Int32(2) && PB.encode(e, 42, x.eos_id)
    x.pad_id != Int32(-1) && PB.encode(e, 43, x.pad_id)
    x.unk_piece != "<unk>" && PB.encode(e, 45, x.unk_piece)
    x.bos_piece != "<s>" && PB.encode(e, 46, x.bos_piece)
    x.eos_piece != "</s>" && PB.encode(e, 47, x.eos_piece)
    x.pad_piece != "<pad>" && PB.encode(e, 48, x.pad_piece)
    x.unk_surface != " \xE2\x81\x87 " && PB.encode(e, 44, x.unk_surface)
    x.train_extremely_large_corpus != false && PB.encode(e, 49, x.train_extremely_large_corpus)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TrainerSpec)
    encoded_size = 0
    !isempty(x.input) && (encoded_size += PB._encoded_size(x.input, 1))
    !isempty(x.input_format) && (encoded_size += PB._encoded_size(x.input_format, 7))
    !isempty(x.model_prefix) && (encoded_size += PB._encoded_size(x.model_prefix, 2))
    x.model_type != var"TrainerSpec.ModelType".UNIGRAM && (encoded_size += PB._encoded_size(x.model_type, 3))
    x.vocab_size != Int32(8000) && (encoded_size += PB._encoded_size(x.vocab_size, 4))
    !isempty(x.accept_language) && (encoded_size += PB._encoded_size(x.accept_language, 5))
    x.self_test_sample_size != Int32(0) && (encoded_size += PB._encoded_size(x.self_test_sample_size, 6))
    x.enable_differential_privacy != false && (encoded_size += PB._encoded_size(x.enable_differential_privacy, 50))
    x.differential_privacy_noise_level != Float32(0.0) && (encoded_size += PB._encoded_size(x.differential_privacy_noise_level, 51))
    x.differential_privacy_clipping_threshold != UInt64(0x0000000000000000) && (encoded_size += PB._encoded_size(x.differential_privacy_clipping_threshold, 52))
    x.character_coverage != Float32(0.9995) && (encoded_size += PB._encoded_size(x.character_coverage, 10))
    x.input_sentence_size != UInt64(0x0000000000000000) && (encoded_size += PB._encoded_size(x.input_sentence_size, 11))
    x.shuffle_input_sentence != true && (encoded_size += PB._encoded_size(x.shuffle_input_sentence, 19))
    x.mining_sentence_size != zero(Int32) && (encoded_size += PB._encoded_size(x.mining_sentence_size, 12))
    x.training_sentence_size != zero(Int32) && (encoded_size += PB._encoded_size(x.training_sentence_size, 13))
    x.seed_sentencepiece_size != Int32(1000000) && (encoded_size += PB._encoded_size(x.seed_sentencepiece_size, 14))
    x.shrinking_factor != Float32(0.75) && (encoded_size += PB._encoded_size(x.shrinking_factor, 15))
    x.max_sentence_length != Int32(4192) && (encoded_size += PB._encoded_size(x.max_sentence_length, 18))
    x.num_threads != Int32(16) && (encoded_size += PB._encoded_size(x.num_threads, 16))
    x.num_sub_iterations != Int32(2) && (encoded_size += PB._encoded_size(x.num_sub_iterations, 17))
    x.max_sentencepiece_length != Int32(16) && (encoded_size += PB._encoded_size(x.max_sentencepiece_length, 20))
    x.split_by_unicode_script != true && (encoded_size += PB._encoded_size(x.split_by_unicode_script, 21))
    x.split_by_number != true && (encoded_size += PB._encoded_size(x.split_by_number, 23))
    x.split_by_whitespace != true && (encoded_size += PB._encoded_size(x.split_by_whitespace, 22))
    x.treat_whitespace_as_suffix != false && (encoded_size += PB._encoded_size(x.treat_whitespace_as_suffix, 24))
    x.allow_whitespace_only_pieces != false && (encoded_size += PB._encoded_size(x.allow_whitespace_only_pieces, 26))
    x.split_digits != false && (encoded_size += PB._encoded_size(x.split_digits, 25))
    x.pretokenization_delimiter != "" && (encoded_size += PB._encoded_size(x.pretokenization_delimiter, 53))
    !isempty(x.control_symbols) && (encoded_size += PB._encoded_size(x.control_symbols, 30))
    !isempty(x.user_defined_symbols) && (encoded_size += PB._encoded_size(x.user_defined_symbols, 31))
    !isempty(x.required_chars) && (encoded_size += PB._encoded_size(x.required_chars, 36))
    x.byte_fallback != false && (encoded_size += PB._encoded_size(x.byte_fallback, 35))
    x.vocabulary_output_piece_score != true && (encoded_size += PB._encoded_size(x.vocabulary_output_piece_score, 32))
    x.hard_vocab_limit != true && (encoded_size += PB._encoded_size(x.hard_vocab_limit, 33))
    x.use_all_vocab != false && (encoded_size += PB._encoded_size(x.use_all_vocab, 34))
    x.unk_id != Int32(0) && (encoded_size += PB._encoded_size(x.unk_id, 40))
    x.bos_id != Int32(1) && (encoded_size += PB._encoded_size(x.bos_id, 41))
    x.eos_id != Int32(2) && (encoded_size += PB._encoded_size(x.eos_id, 42))
    x.pad_id != Int32(-1) && (encoded_size += PB._encoded_size(x.pad_id, 43))
    x.unk_piece != "<unk>" && (encoded_size += PB._encoded_size(x.unk_piece, 45))
    x.bos_piece != "<s>" && (encoded_size += PB._encoded_size(x.bos_piece, 46))
    x.eos_piece != "</s>" && (encoded_size += PB._encoded_size(x.eos_piece, 47))
    x.pad_piece != "<pad>" && (encoded_size += PB._encoded_size(x.pad_piece, 48))
    x.unk_surface != " \xE2\x81\x87 " && (encoded_size += PB._encoded_size(x.unk_surface, 44))
    x.train_extremely_large_corpus != false && (encoded_size += PB._encoded_size(x.train_extremely_large_corpus, 49))
    return encoded_size
end

struct ModelProto
    pieces::Vector{var"ModelProto.SentencePiece"}
    trainer_spec::Union{Nothing,TrainerSpec}
    normalizer_spec::Union{Nothing,NormalizerSpec}
    self_test_data::Union{Nothing,SelfTestData}
    denormalizer_spec::Union{Nothing,NormalizerSpec}
end
PB.extendable_field_numbers(::Type{ModelProto}) = Union{Int,UnitRange{Int}}[200:536870911]
PB.default_values(::Type{ModelProto}) = (;pieces = Vector{var"ModelProto.SentencePiece"}(), trainer_spec = nothing, normalizer_spec = nothing, self_test_data = nothing, denormalizer_spec = nothing)
PB.field_numbers(::Type{ModelProto}) = (;pieces = 1, trainer_spec = 2, normalizer_spec = 3, self_test_data = 4, denormalizer_spec = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ModelProto})
    pieces = PB.BufferedVector{var"ModelProto.SentencePiece"}()
    trainer_spec = Ref{Union{Nothing,TrainerSpec}}(nothing)
    normalizer_spec = Ref{Union{Nothing,NormalizerSpec}}(nothing)
    self_test_data = Ref{Union{Nothing,SelfTestData}}(nothing)
    denormalizer_spec = Ref{Union{Nothing,NormalizerSpec}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, pieces)
        elseif field_number == 2
            PB.decode!(d, trainer_spec)
        elseif field_number == 3
            PB.decode!(d, normalizer_spec)
        elseif field_number == 4
            PB.decode!(d, self_test_data)
        elseif field_number == 5
            PB.decode!(d, denormalizer_spec)
        else
            PB.skip(d, wire_type)
        end
    end
    return ModelProto(pieces[], trainer_spec[], normalizer_spec[], self_test_data[], denormalizer_spec[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ModelProto)
    initpos = position(e.io)
    !isempty(x.pieces) && PB.encode(e, 1, x.pieces)
    !isnothing(x.trainer_spec) && PB.encode(e, 2, x.trainer_spec)
    !isnothing(x.normalizer_spec) && PB.encode(e, 3, x.normalizer_spec)
    !isnothing(x.self_test_data) && PB.encode(e, 4, x.self_test_data)
    !isnothing(x.denormalizer_spec) && PB.encode(e, 5, x.denormalizer_spec)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ModelProto)
    encoded_size = 0
    !isempty(x.pieces) && (encoded_size += PB._encoded_size(x.pieces, 1))
    !isnothing(x.trainer_spec) && (encoded_size += PB._encoded_size(x.trainer_spec, 2))
    !isnothing(x.normalizer_spec) && (encoded_size += PB._encoded_size(x.normalizer_spec, 3))
    !isnothing(x.self_test_data) && (encoded_size += PB._encoded_size(x.self_test_data, 4))
    !isnothing(x.denormalizer_spec) && (encoded_size += PB._encoded_size(x.denormalizer_spec, 5))
    return encoded_size
end
